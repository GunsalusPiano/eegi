"""Utility module for helping converting between well and tile.

    - Well, e.g. 'A01', is the canonical way of referring to a position in a
      plate. This is what is used throughout the database.

    - Tile, e.g. 'Tile000001', is the prefix with which the microscope
      software saves our images (as Tile000001.bmp), and the convention that
      DevStaR uses for the corresponding output (Tile000001res.png and
      Tile000001cnt.txt).

  While the legacy database was inconsistent in using 'well' in some
  tables and 'tile' in other tables, the new database uses 'well'
  consistenly. However, translating to tiles is still needed, to
  access the image and DevStaR filenames, and to sync the legacy
  database to this database.

"""

import re

from constants import ROWS_96, NUM_COLS_96
from well_naming import get_well_name

BACKWARDS_ROWS = 'BDFH'


def well_to_tile(well):
    """Convert a well (e.g. 'B05') to a tile (e.g. 'Tile000020')."""
    index = well_to_index(well)
    return index_to_tile(index)


def tile_to_well(tile):
    """Convert a tile (e.g. 'Tile000020') to a well (e.g. 'B05')."""
    index = tile_to_index(tile)
    return index_to_well(index)


def well_to_index(well):
    """Convert a well (e.g. 'B05') to the 0-indexed plate position as
    generated by our scopes (e.g. 19).

    The order generated by our scopes snakes back and forth each row, like:

        A01, A02, ..., A12, B12, B11, ..., B01, C01, ...

    """
    if not re.match('[A-H]\d\d?', well):
        raise ValueError('Improper well string')
    row = well[0]
    column = int(well[1:])
    position_from_left = column - 1
    assert position_from_left >= 0 and position_from_left < NUM_COLS_96

    min_row_index = (ord(row) - 65) * NUM_COLS_96
    if row in BACKWARDS_ROWS:
        index_in_row = NUM_COLS_96 - 1 - position_from_left
    else:
        index_in_row = position_from_left

    overall_index = min_row_index + index_in_row
    return overall_index


def index_to_well(index):
    """Convert a 0-indexed plate position as generated by our scopres (e.g. 19)
    to a well (e.g. 'B05').

    The order generated by our scopes snakes back and forth each row, like:

        A01, A02, ..., A12, B12, B11, ..., B01, C01, ...

    """
    row = ROWS_96[index / NUM_COLS_96]
    index_in_row = index % NUM_COLS_96

    if row in BACKWARDS_ROWS:
        position_from_left = NUM_COLS_96 - 1 - index_in_row
    else:
        position_from_left = index_in_row

    column = position_from_left + 1
    return get_well_name(row, column)


def tile_to_index(tile):
    """Convert a tile (in format 'Tile000020', with trailing characters
    allowed) to the 0-indexed position in the order generated by our scopes.

    The order generated by our scopes snakes back and forth each row, like:

        A01, A02, ..., A12, B12, B11, ..., B01, C01, ...

    """
    if not re.match('Tile0000\d\d.*', tile):
        raise ValueError('Improper tile string')

    index = int(tile[8:10]) - 1
    return index


def index_to_tile(index):
    """Convert a 0-indexed plate position as generated by our scores (e.g. 19)
    to a tile (e.g. 'Tile000020').

    The order generated by our scopes snakes back and forth each row, like:

        A01, A02, ..., A12, B12, B11, ..., B01, C01, ...

    """
    return 'Tile0000{}'.format(str(index + 1).zfill(2))


if __name__ == '__main__':
    tests = (
        ('A01', 'Tile000001'),
        ('A12', 'Tile000012'),
        ('B12', 'Tile000013'),
        ('B01', 'Tile000024'),
        ('C02', 'Tile000026'),
        ('H12', 'Tile000085'),
        ('H01', 'Tile000096'),
    )

    for test in tests:
        if well_to_tile(test[0]) != test[1]:
            print 'fail:' + well_to_tile(test[0])
        elif tile_to_well(test[1]) != test[0]:
            print 'FAIL: ' + tile_to_well(test[1])
        else:
            print 'success'
